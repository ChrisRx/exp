// Code generated by aliaspkg. DO NOT EDIT.

package slices

// Package slices defines various functions useful with slices of any type.

import (
	"cmp"
	"iter"
	"slices"
)

// All returns an iterator over index-value pairs in the slice
// in the usual order.
//
// This is an alias of https://pkg.go.dev/slices#All.
func All[Slice ~[]E, E any](s Slice) iter.Seq2[int, E] {
	return slices.All[Slice, E](s)
}

// Backward returns an iterator over index-value pairs in the slice,
// traversing it backward with descending indices.
//
// This is an alias of https://pkg.go.dev/slices#Backward.
func Backward[Slice ~[]E, E any](s Slice) iter.Seq2[int, E] {
	return slices.Backward[Slice, E](s)
}

// Values returns an iterator that yields the slice elements in order.
//
// This is an alias of https://pkg.go.dev/slices#Values.
func Values[Slice ~[]E, E any](s Slice) iter.Seq[E] {
	return slices.Values[Slice, E](s)
}

// AppendSeq appends the values from seq to the slice and
// returns the extended slice.
//
// This is an alias of https://pkg.go.dev/slices#AppendSeq.
func AppendSeq[Slice ~[]E, E any](s Slice, seq iter.Seq[E]) Slice {
	return slices.AppendSeq[Slice, E](s, seq)
}

// Collect collects values from seq into a new slice and returns it.
//
// This is an alias of https://pkg.go.dev/slices#Collect.
func Collect[E any](seq iter.Seq[E]) []E {
	return slices.Collect[E](seq)
}

// Sorted collects values from seq into a new slice, sorts the slice,
// and returns it.
//
// This is an alias of https://pkg.go.dev/slices#Sorted.
func Sorted[E cmp.Ordered](seq iter.Seq[E]) []E {
	return slices.Sorted[E](seq)
}

// SortedFunc collects values from seq into a new slice, sorts the slice
// using the comparison function, and returns it.
//
// This is an alias of https://pkg.go.dev/slices#SortedFunc.
func SortedFunc[E any](seq iter.Seq[E], cmp func(E, E) int) []E {
	return slices.SortedFunc[E](seq, cmp)
}

// SortedStableFunc collects values from seq into a new slice.
// It then sorts the slice while keeping the original order of equal elements,
// using the comparison function to compare elements.
// It returns the new slice.
//
// This is an alias of https://pkg.go.dev/slices#SortedStableFunc.
func SortedStableFunc[E any](seq iter.Seq[E], cmp func(E, E) int) []E {
	return slices.SortedStableFunc[E](seq, cmp)
}

// Chunk returns an iterator over consecutive sub-slices of up to n elements of s.
// All but the last sub-slice will have size n.
// All sub-slices are clipped to have no capacity beyond the length.
// If s is empty, the sequence is empty: there is no empty slice in the sequence.
// Chunk panics if n is less than 1.
//
// This is an alias of https://pkg.go.dev/slices#Chunk.
func Chunk[Slice ~[]E, E any](s Slice, n int) iter.Seq[Slice] {
	return slices.Chunk[Slice, E](s, n)
}

// Equal reports whether two slices are equal: the same length and all
// elements equal. If the lengths are different, Equal returns false.
// Otherwise, the elements are compared in increasing index order, and the
// comparison stops at the first unequal pair.
// Empty and nil slices are considered equal.
// Floating point NaNs are not considered equal.
//
// This is an alias of https://pkg.go.dev/slices#Equal.
func Equal[S ~[]E, E comparable](s1, s2 S) bool {
	return slices.Equal[S, E](s1, s2)
}

// EqualFunc reports whether two slices are equal using an equality
// function on each pair of elements. If the lengths are different,
// EqualFunc returns false. Otherwise, the elements are compared in
// increasing index order, and the comparison stops at the first index
// for which eq returns false.
//
// This is an alias of https://pkg.go.dev/slices#EqualFunc.
func EqualFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, eq func(E1, E2) bool) bool {
	return slices.EqualFunc[S1, S2, E1, E2](s1, s2, eq)
}

// Compare compares the elements of s1 and s2, using [cmp.Compare] on each pair
// of elements. The elements are compared sequentially, starting at index 0,
// until one element is not equal to the other.
// The result of comparing the first non-matching elements is returned.
// If both slices are equal until one of them ends, the shorter slice is
// considered less than the longer one.
// The result is 0 if s1 == s2, -1 if s1 < s2, and +1 if s1 > s2.
//
// This is an alias of https://pkg.go.dev/slices#Compare.
func Compare[S ~[]E, E cmp.Ordered](s1, s2 S) int {
	return slices.Compare[S, E](s1, s2)
}

// CompareFunc is like [Compare] but uses a custom comparison function on each
// pair of elements.
// The result is the first non-zero result of cmp; if cmp always
// returns 0 the result is 0 if len(s1) == len(s2), -1 if len(s1) < len(s2),
// and +1 if len(s1) > len(s2).
//
// This is an alias of https://pkg.go.dev/slices#CompareFunc.
func CompareFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, cmp func(E1, E2) int) int {
	return slices.CompareFunc[S1, S2, E1, E2](s1, s2, cmp)
}

// Index returns the index of the first occurrence of v in s,
// or -1 if not present.
//
// This is an alias of https://pkg.go.dev/slices#Index.
func Index[S ~[]E, E comparable](s S, v E) int {
	return slices.Index[S, E](s, v)
}

// IndexFunc returns the first index i satisfying f(s[i]),
// or -1 if none do.
//
// This is an alias of https://pkg.go.dev/slices#IndexFunc.
func IndexFunc[S ~[]E, E any](s S, f func(E) bool) int {
	return slices.IndexFunc[S, E](s, f)
}

// Contains reports whether v is present in s.
//
// This is an alias of https://pkg.go.dev/slices#Contains.
func Contains[S ~[]E, E comparable](s S, v E) bool {
	return slices.Contains[S, E](s, v)
}

// ContainsFunc reports whether at least one
// element e of s satisfies f(e).
//
// This is an alias of https://pkg.go.dev/slices#ContainsFunc.
func ContainsFunc[S ~[]E, E any](s S, f func(E) bool) bool {
	return slices.ContainsFunc[S, E](s, f)
}

// Insert inserts the values v... into s at index i,
// returning the modified slice.
// The elements at s[i:] are shifted up to make room.
// In the returned slice r, r[i] == v[0],
// and, if i < len(s), r[i+len(v)] == value originally at r[i].
// Insert panics if i > len(s).
// This function is O(len(s) + len(v)).
//
// This is an alias of https://pkg.go.dev/slices#Insert.
func Insert[S ~[]E, E any](s S, i int, v ...E) S {
	return slices.Insert[S, E](s, i, v...)
}

// Delete removes the elements s[i:j] from s, returning the modified slice.
// Delete panics if j > len(s) or s[i:j] is not a valid slice of s.
// Delete is O(len(s)-i), so if many items must be deleted, it is better to
// make a single call deleting them all together than to delete one at a time.
// Delete zeroes the elements s[len(s)-(j-i):len(s)].
//
// This is an alias of https://pkg.go.dev/slices#Delete.
func Delete[S ~[]E, E any](s S, i, j int) S {
	return slices.Delete[S, E](s, i, j)
}

// DeleteFunc removes any elements from s for which del returns true,
// returning the modified slice.
// DeleteFunc zeroes the elements between the new length and the original length.
//
// This is an alias of https://pkg.go.dev/slices#DeleteFunc.
func DeleteFunc[S ~[]E, E any](s S, del func(E) bool) S {
	return slices.DeleteFunc[S, E](s, del)
}

// Replace replaces the elements s[i:j] by the given v, and returns the
// modified slice.
// Replace panics if j > len(s) or s[i:j] is not a valid slice of s.
// When len(v) < (j-i), Replace zeroes the elements between the new length and the original length.
//
// This is an alias of https://pkg.go.dev/slices#Replace.
func Replace[S ~[]E, E any](s S, i, j int, v ...E) S {
	return slices.Replace[S, E](s, i, j, v...)
}

// Clone returns a copy of the slice.
// The elements are copied using assignment, so this is a shallow clone.
// The result may have additional unused capacity.
//
// This is an alias of https://pkg.go.dev/slices#Clone.
func Clone[S ~[]E, E any](s S) S {
	return slices.Clone[S, E](s)
}

// Compact replaces consecutive runs of equal elements with a single copy.
// This is like the uniq command found on Unix.
// Compact modifies the contents of the slice s and returns the modified slice,
// which may have a smaller length.
// Compact zeroes the elements between the new length and the original length.
//
// This is an alias of https://pkg.go.dev/slices#Compact.
func Compact[S ~[]E, E comparable](s S) S {
	return slices.Compact[S, E](s)
}

// CompactFunc is like [Compact] but uses an equality function to compare elements.
// For runs of elements that compare equal, CompactFunc keeps the first one.
// CompactFunc zeroes the elements between the new length and the original length.
//
// This is an alias of https://pkg.go.dev/slices#CompactFunc.
func CompactFunc[S ~[]E, E any](s S, eq func(E, E) bool) S {
	return slices.CompactFunc[S, E](s, eq)
}

// Grow increases the slice's capacity, if necessary, to guarantee space for
// another n elements. After Grow(n), at least n elements can be appended
// to the slice without another allocation. If n is negative or too large to
// allocate the memory, Grow panics.
//
// This is an alias of https://pkg.go.dev/slices#Grow.
func Grow[S ~[]E, E any](s S, n int) S {
	return slices.Grow[S, E](s, n)
}

// Clip removes unused capacity from the slice, returning s[:len(s):len(s)].
//
// This is an alias of https://pkg.go.dev/slices#Clip.
func Clip[S ~[]E, E any](s S) S {
	return slices.Clip[S, E](s)
}

// Concat returns a new slice concatenating the passed in slices.
//
// This is an alias of https://pkg.go.dev/slices#Concat.
func Concat[S ~[]E, E any](slices_ ...S) S {
	return slices.Concat[S, E](slices_...)
}

// Repeat returns a new slice that repeats the provided slice the given number of times.
// The result has length and capacity (len(x) * count).
// The result is never nil.
// Repeat panics if count is negative or if the result of (len(x) * count)
// overflows.
//
// This is an alias of https://pkg.go.dev/slices#Repeat.
func Repeat[S ~[]E, E any](x S, count int) S {
	return slices.Repeat[S, E](x, count)
}

// SortFunc sorts the slice x in ascending order as determined by the cmp
// function. This sort is not guaranteed to be stable.
// cmp(a, b) should return a negative number when a < b, a positive number when
// a > b and zero when a == b or a and b are incomparable in the sense of
// a strict weak ordering.
//
// SortFunc requires that cmp is a strict weak ordering.
// See https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings.
// The function should return 0 for incomparable items.
//
// This is an alias of https://pkg.go.dev/slices#SortFunc.
func SortFunc[S ~[]E, E any](x S, cmp func(a, b E) int) {
	slices.SortFunc[S, E](x, cmp)
}

// SortStableFunc sorts the slice x while keeping the original order of equal
// elements, using cmp to compare elements in the same way as [SortFunc].
//
// This is an alias of https://pkg.go.dev/slices#SortStableFunc.
func SortStableFunc[S ~[]E, E any](x S, cmp func(a, b E) int) {
	slices.SortStableFunc[S, E](x, cmp)
}

// IsSorted reports whether x is sorted in ascending order.
//
// This is an alias of https://pkg.go.dev/slices#IsSorted.
func IsSorted[S ~[]E, E cmp.Ordered](x S) bool {
	return slices.IsSorted[S, E](x)
}

// IsSortedFunc reports whether x is sorted in ascending order, with cmp as the
// comparison function as defined by [SortFunc].
//
// This is an alias of https://pkg.go.dev/slices#IsSortedFunc.
func IsSortedFunc[S ~[]E, E any](x S, cmp func(a, b E) int) bool {
	return slices.IsSortedFunc[S, E](x, cmp)
}

// Min returns the minimal value in x. It panics if x is empty.
// For floating-point numbers, Min propagates NaNs (any NaN value in x
// forces the output to be NaN).
//
// This is an alias of https://pkg.go.dev/slices#Min.
func Min[S ~[]E, E cmp.Ordered](x S) E {
	return slices.Min[S, E](x)
}

// MinFunc returns the minimal value in x, using cmp to compare elements.
// It panics if x is empty. If there is more than one minimal element
// according to the cmp function, MinFunc returns the first one.
//
// This is an alias of https://pkg.go.dev/slices#MinFunc.
func MinFunc[S ~[]E, E any](x S, cmp func(a, b E) int) E {
	return slices.MinFunc[S, E](x, cmp)
}

// Max returns the maximal value in x. It panics if x is empty.
// For floating-point E, Max propagates NaNs (any NaN value in x
// forces the output to be NaN).
//
// This is an alias of https://pkg.go.dev/slices#Max.
func Max[S ~[]E, E cmp.Ordered](x S) E {
	return slices.Max[S, E](x)
}

// MaxFunc returns the maximal value in x, using cmp to compare elements.
// It panics if x is empty. If there is more than one maximal element
// according to the cmp function, MaxFunc returns the first one.
//
// This is an alias of https://pkg.go.dev/slices#MaxFunc.
func MaxFunc[S ~[]E, E any](x S, cmp func(a, b E) int) E {
	return slices.MaxFunc[S, E](x, cmp)
}

// BinarySearch searches for target in a sorted slice and returns the earliest
// position where target is found, or the position where target would appear
// in the sort order; it also returns a bool saying whether the target is
// really found in the slice. The slice must be sorted in increasing order.
//
// This is an alias of https://pkg.go.dev/slices#BinarySearch.
func BinarySearch[S ~[]E, E cmp.Ordered](x S, target E) (int, bool) {
	return slices.BinarySearch[S, E](x, target)
}

// BinarySearchFunc works like [BinarySearch], but uses a custom comparison
// function. The slice must be sorted in increasing order, where "increasing"
// is defined by cmp. cmp should return 0 if the slice element matches
// the target, a negative number if the slice element precedes the target,
// or a positive number if the slice element follows the target.
// cmp must implement the same ordering as the slice, such that if
// cmp(a, t) < 0 and cmp(b, t) >= 0, then a must precede b in the slice.
//
// This is an alias of https://pkg.go.dev/slices#BinarySearchFunc.
func BinarySearchFunc[S ~[]E, E, T any](x S, target T, cmp func(E, T) int) (int, bool) {
	return slices.BinarySearchFunc[S, E, T](x, target, cmp)
}
